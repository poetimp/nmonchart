#!/usr/bin/perl -w
#------------------------------------------------------------------------------------------
#
# Program: nmon2graphite
# Author:  Paul Lemmons
# Date:    09/05/2017
# Description:
#          This program will read a file generated by nmon, running in batch mode
#------------------------------------------------------------------------------------------
#  C H A N G E   H I S T O R Y
#------------------------------------------------------------------------------------------
#  09/05/2017    Paul Lemmons                  Initial setup.
#------------------------------------------------------------------------------------------

use strict;
use TMC::Monolith;
use TMC::DoDie qw(do_die do_warn);
use List::Util qw[min max];
use Scalar::Util qw(looks_like_number);
use POSIX qw(strftime);
use LWP::UserAgent;
use Time::Local;

#-----------------------------------------------------------------------------------------------
# Subroutine prototypes
#-----------------------------------------------------------------------------------------------
sub consumeNmonData();
sub printPageTop();
sub printPageBottom();
sub printhtml($);
sub buildConfig();
sub buildChart($$$@);
sub buildButton($$$);
sub printPageMiddle();
#-----------------------------------------------------------------------------------------------
# Instantiate communication modules
#-----------------------------------------------------------------------------------------------
my $monolith = new TMC::Monolith;
my $do_die   = new TMC::DoDie({emailList =>'paul.lemmons@tmcaz.com'});

#-----------------------------------------------------------------------------------------------
# Configuration Variables
#-----------------------------------------------------------------------------------------------
my $READABLEHTML = 0;

#-----------------------------------------------------------------------------------------------
# Global variable
#-----------------------------------------------------------------------------------------------
my %descriptors   = ();
my %perfData      = ();
my $startTime     = '';
my $startDate     = '';
my $hostname      = '';
my $hosttype      = '';
my %globalData    = ();
my @osDetails     = ();
my %bbbData       = ();
my $Stacked       = 1;
my $unStacked     = 0;

#-----------------------------------------------------------------------------------------------
# Read and parse the nmn file into the global perfData hash 
#-----------------------------------------------------------------------------------------------
consumeNmonData();

#-----------------------------------------------------------------------------------------------
# Start page creation.... 
#-----------------------------------------------------------------------------------------------

printPageTop();

buildChart('CPU_UTIL'   ,'CPU_ALL'  ,$Stacked,   'CPU Utilisation Percentages'                                           ,('SysPct','UserPct','WaitPct','IdlePct'));
buildChart('MEM_LINUX'  ,'MEM'      ,$unStacked, 'Real Memory - RAM in MB'                                               ,('memtotal','memfree','cached','active','buffers','inactive'));
buildChart('SWAP_LINUX' ,'MEM'      ,$unStacked, 'Virtual Memory - Paging Space in MB'                                   ,('swaptotal','swapfree'));
buildChart('RUNQ'       ,'PROC'     ,$unStacked, 'Run Queue - processes that running or ready to run'                    ,('Runnable'));
buildChart('PSWITCH'    ,'PROC'     ,$unStacked, 'Process Switches per second - between processes'                       ,('pswitch'));
buildChart('FORKEXEC'   ,'PROC'     ,$unStacked, 'Fork() and Exec() System Calls per second - creating processes'        ,('fork', 'exec'));
buildChart('NET'        ,'NET'      ,$unStacked, 'Network Receive(read) & Send(write shown negatively) in KB per second' ,('*'));
buildChart('NETPACKET'  ,'NETPACKET',$unStacked, 'Network packet count per second'                                       ,('*'));
buildChart('DISKBUSY'   ,'DISKBUSY' ,$Stacked,   'Disk Busy Percentage of the time (Stacked)'                            ,('*'));
buildChart('DISKBUSYu'  ,'DISKBUSY' ,$unStacked, 'Disk Busy Percentage of the time (Unstacked)'                          ,('*'));
buildChart('DISKREAD'   ,'DISKREAD' ,$Stacked,   'Disk Read KB per second (Stacked)'                                     ,('*'));
buildChart('DISKREADu'  ,'DISKREAD' ,$unStacked, 'Disk Read KB per second (Unstacked)'                                   ,('*'));
buildChart('DISKWRITE'  ,'DISKWRITE',$Stacked,   'Disk Write KB per second (Stacked)'                                    ,('*'));
buildChart('DISKWRITEu' ,'DISKWRITE',$unStacked, 'Disk Write KB per second (Unstacked)'                                  ,('*'));
buildChart('DISKBSIZE'  ,'DISKBSIZE',$unStacked, 'Disk Block Size KB'                                                    ,('*'));
buildChart('DISKXFER'   ,'DISKXFER' ,$unStacked, 'Disk Transfers per second'                                             ,('*'));

printPageMiddle();

buildButton("CPU_UTIL"     ,"CPU Util."        ,"red");
buildButton("RUNQ"         ,"RunQ"             ,"red");
buildButton("PSWITCH"      ,"pSwitch"          ,"red");
buildButton("FORKEXEC"     ,"ForkExec"         ,"red");
buildButton("MEM_LINUX"    ,"Memory"           ,"blue");
buildButton("SWAP_LINUX"   ,"Swap"             ,"blue");
printhtml(qq[      <br>]);
buildButton("NET"          ,"Network"          ,"purple");
buildButton("NETPACKET"    ,"Net Packet"       ,"purple");
buildButton("DISKBUSY"     ,"Disk Busy"        ,"brown");
buildButton("DISKBUSYu"    ,"&lt;-Unstacked"   ,"brown");
buildButton("DISKREAD"     ,"Disk Read"        ,"brown");
buildButton("DISKREADu"    ,"&lt;-Unstacked"   ,"brown");
buildButton("DISKWRITE"    ,"Disk Write"       ,"brown");
buildButton("DISKWRITEu"   ,"&lt;-Unstacked"   ,"brown");
buildButton("DISKBSIZE"    ,"Disk BSize"       ,"brown");
buildButton("DISKXFER"     ,"Disk Xfers"       ,"brown");

printPageBottom();

#-----------------------------------------------------------------------------------------------
#  The program has been written such that the html can be written in suc a way that it is 
# readable by us humans. But we like a lot of white space that the computer really does not.
# if you are debugging set the READABLEHTML variable to 1. Otherwise set ot to 0 to significantly
# reduce bandwidth. 
#-----------------------------------------------------------------------------------------------
sub printhtml($)
{
   
   my $line=shift;
   
   if(!$READABLEHTML)
   {
      $line =~ s/^\s+|\s+$//; # trim left and right
      $line =~ s/(\s)\s+/$1/; # Compress blanks
      $line =~ s/\\$/ /;      # concattonate lines that were continued in the javascript
      print "$line";
   }
   else
   {
      print "$line\n";
   }
}

#-----------------------------------------------------------------------------------------------
#  The top of the web page that is being built is basicly static. 
#-----------------------------------------------------------------------------------------------
sub printPageTop()
{
   #---------------------------------------------------------------------------------------------------
   # Product the top part of the web page 
   #---------------------------------------------------------------------------------------------------
   printhtml(qq[<html>]);
   printhtml(qq[   <head>]);
   printhtml(qq[      <title>nmonChart</title>]);
   
   buildConfig();
   
   printhtml(qq[      <script type="text/javascript" src="https://www.google.com/jsapi"></script>]);
   printhtml(qq[      <script type="text/javascript">]);
   printhtml(qq[         google.load("visualization", "1.1",]);
   printhtml(qq[                       {]);
   printhtml(qq[                          packages : [ "corechart" ]]);
   printhtml(qq[                       }]);
   printhtml(qq[                    );]);
   printhtml(qq[]);
   printhtml(qq[         google.setOnLoadCallback(setupCharts);]);
   printhtml(qq[]);
   printhtml(qq[         function setupCharts()]);
   printhtml(qq[         {]);
   printhtml(qq[]);
   printhtml(qq[            var chart = null;]);
}
#-----------------------------------------------------------------------------------------------
#  There is some code that occurs between the bittons and the charts. 
#-----------------------------------------------------------------------------------------------
sub printPageMiddle()
{   
   printhtml(qq[         }]);
   printhtml(qq[      </script>]);
   printhtml(qq[   </head>]);
   
   printhtml(qq[   <body bgcolor="#EEEEFF">]);
   printhtml(qq[      <button onclick="config()">]);
   printhtml(qq[         <b>Configuration</b>]);
   printhtml(qq[      </button>]);
   printhtml(qq[      <br>]);
}
#-----------------------------------------------------------------------------------------------
#  Finishe the web page by adding foodter information
#-----------------------------------------------------------------------------------------------
sub printPageBottom()
{   
   printhtml(qq[   <div id="chart_master" style="width: 100%; height: 75%;">]);
   printhtml(qq[      <h2 style="color: blue">Click on a Graph button above, to]);
   printhtml(qq[         display that graph</h2>]);
   printhtml(qq[   </div>]);
   printhtml(qq[]);
   printhtml(qq[   <table>]);
   printhtml(qq[      <tr>]);
   printhtml(qq[         <td>]);
   printhtml(qq[            <li>Host:tpcloverleaf]);
   printhtml(qq[         <li>Date: ].$globalData{'date'});
   printhtml(qq[         <li>Time: ].$globalData{'time'});
   printhtml(qq[         <li>Interval: ].$globalData{'interval'});
   printhtml(qq[         <li>Snapshots: ].$globalData{'snapshots'});
   printhtml(qq[         <td>]);
   printhtml(qq[            <li>Number of CPUs: ].$globalData{'cpus'});
   printhtml(qq[         <li>Number of Disks: ].$globalData{'disks'});
   printhtml(qq[         <li>Linux Kernel: ].$osDetails[0]);
   printhtml(qq[         <li>Linux Version: ].$bbbData{'001-/etc/release'});
   printhtml(qq[]);
   printhtml(qq[         <td valign=top>]);
   printhtml(qq[            <hr>]);
   printhtml(qq[            <li>Graphed by nmonchart.pl v 0.1]);
   printhtml(qq[         <li>Developer: Paul Lemmons (perl Code) Nigel Griffiths (Chart Javascrpt)]);
   printhtml(qq[         <li>Zoom=ON Left-click & Drag=Zoom-in. Right-click=Reset.]);
   printhtml(qq[]);
   printhtml(qq[   </table>]);
   printhtml(qq[</body>]);
}
#-----------------------------------------------------------------------------------------------
#  There is a pop-out page that shows all of the configuration information for the system. This
# code builds that page.
#-----------------------------------------------------------------------------------------------
sub buildConfig()
{
   my $startDate = $globalData{'date'};
   printhtml(qq[      <script>]);
   printhtml(qq[         function config()]);
   printhtml(qq[         {]);
   printhtml(qq[            var myWindow = window.open("", "MsgWindow", "width=1024, height=800");]);
   printhtml(qq[            myWindow.document.write("<h2>Configuration data for $startDate <br>Use PageDown or Scroll bar (if available)</h2><br>\\]);
   foreach my $configItem (sort(keys(%globalData)))
   {
      $globalData{$configItem} =~ s/"//g;
      
      printhtml(qq[                                        <b>].$configItem.qq[</b> = ].$globalData{$configItem}.qq[<br>\\]);
   }
   
   foreach my $configItem (sort(keys(%bbbData)))
   {
      my $label =  $configItem;
         $label =~ s/^\d+-//;
         
      $bbbData{$configItem} =~ s/"//g;
      
      printhtml(qq[                                        <b>].$label.qq[</b> = ].$bbbData{$configItem}.qq[<br>\\]);
   }
   printhtml(qq[                                    ");]);
   printhtml(qq[         }]);
   printhtml(qq[      </script>]);
}
#-----------------------------------------------------------------------------------------------
#  Build a chart based on the options passed to it.
#-----------------------------------------------------------------------------------------------
sub buildChart($$$@)
{
   my $chartName    = shift;
   my $chartMetric  = shift;
   my $chartStacked = shift;
   my $chartTitle   = shift;
   my @chartItems   = @_;  
   
   my %chartMap = map { $_ => 1 } @chartItems;
   my $allFields = ($chartItems[0] eq '*');
   
   printhtml(qq[            var data_$chartName = google.visualization.arrayToDataTable(\[ \[]);
   printhtml(qq[                                  {]);
   printhtml(qq[                                     type  : 'datetime',]);
   printhtml(qq[                                     label : 'Datetime']);

   my $printHeadings=1;
   my @items=();
   foreach my $snapshot (sort(keys(%perfData)))
   {
      #print "$snapshot\n";
      if ($printHeadings)
      {
         printhtml(qq[                                  } ]);

         if ($allFields)
         {
            foreach my $item (sort(keys(%{$perfData{$snapshot}->{$chartMetric}})))
            {
               printhtml(qq[                                    ,'$item']);
               push(@items,$item);
            }
         }
         else
         {
            foreach my $item (@chartItems)
            {
               printhtml(qq[                                    ,'$item']);
               push(@items,$item);
            }
         }
         printhtml(qq[                                   \]]);
         
         $printHeadings=0;
      }
      
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($perfData{$snapshot}->{'timestamp'});
      $year+=1900;
      printhtml(qq[                                   ,\[]. qq['Date($year,$mon,$mday,$hour,$min,$sec)'] );
      foreach my $item (@items)
      {
         if ($allFields or defined($chartMap{$item}))
         {
            $perfData{$snapshot}->{$chartMetric}->{$item}=0 if $perfData{$snapshot}->{$chartMetric}->{$item} eq '';
            
            printhtml(qq[                                    ,].$perfData{$snapshot}->{$chartMetric}->{$item});
         }
      }
      printhtml(qq[                                   \]]);

   }
   printhtml(qq[                                 \]]);
   printhtml(qq[                              );]);
   printhtml(qq[            var options_$chartName = {]);
   printhtml(qq[                     chartArea : {]);
   printhtml(qq[                        left : "5%",]);
   printhtml(qq[                        width : "85%",]);
   printhtml(qq[                        top : "10%",]);
   printhtml(qq[                        height : "80%"]);
   printhtml(qq[                     },]);
   printhtml(qq[                     title : "$chartTitle",]);
   printhtml(qq[                     focusTarget : "category",]);
   printhtml(qq[                     hAxis : {]);
   printhtml(qq[                        gridlines : {]);
   printhtml(qq[                           color : "lightgrey",]);
   printhtml(qq[                           count : 30]);
   printhtml(qq[                        }]);
   printhtml(qq[                     },]);
   printhtml(qq[                     vAxis : {]);
   printhtml(qq[                        gridlines : {]);
   printhtml(qq[                           color : "lightgrey",]);
   printhtml(qq[                           count : 11]);
   printhtml(qq[                        }]);
   printhtml(qq[                     },]);
   printhtml(qq[                     explorer : {]);
   printhtml(qq[                        actions : [ "dragToZoom", "rightClickToReset" ],]);
   printhtml(qq[                        axis : "horizontal",]);
   printhtml(qq[                        keepInBounds : true,]);
   printhtml(qq[                        maxZoomIn : 20.0]);
   printhtml(qq[                     },]);
   printhtml(qq[                     isStacked : $chartStacked]);
   printhtml(qq[                  };]);
   printhtml(qq[            ]);
   printhtml(qq[                  document.getElementById("draw_$chartName").addEventListener(]);
   printhtml(qq[                        "click",]);
   printhtml(qq[                        function()]);
   printhtml(qq[                        {]);
   printhtml(qq[                           if (chart && chart.clearChart)]);
   printhtml(qq[                              chart.clearChart();]);
   printhtml(qq[            ]);
   printhtml(qq[                           chart = new google.visualization.AreaChart(document]);
   printhtml(qq[                                 .getElementById("chart_master"));]);
   printhtml(qq[                           chart.draw(data_$chartName, options_$chartName);]);
   printhtml(qq[                        });]);

}
#-----------------------------------------------------------------------------------------------
#  There shold be a button associated with each chart that is built
#-----------------------------------------------------------------------------------------------
sub buildButton($$$)
{
   my $buttonName  = shift;
   my $buttonText  = shift;
   my $buttonColor = shift;
   
   printhtml(qq[   <button id="draw_$buttonName" style="color: $buttonColor;">]);
   printhtml(qq[      <b>$buttonText</b>]);
   printhtml(qq[   </button>]);
}
#-----------------------------------------------------------------------------------------------
#  Read all of the nmon data and parse it into a hash so we can access quickly
#-----------------------------------------------------------------------------------------------
sub consumeNmonData()
{
   #-----------------------------------------------------------------------------------------------
   # Read the file supplied on the command line or piped into this script
   #-----------------------------------------------------------------------------------------------
   while(defined(my $line = <>))
   {
      chomp($line);
      my @fields = split(/,/,$line);
      
      #------------------------------------------------------------------------------------------------
      # Capture the global configuration data
      #------------------------------------------------------------------------------------------------
      if ($fields[0] =~ /^AAA/)
      {
         if   ($fields[1] =~ /x86/)   
         {
            $globalData{$fields[1].'-'.$fields[2]} = $fields[3];
         }
         elsif   ($fields[1] =~ /OS/)   
         {
            my $j=3;
            while(defined($fields[$j]))
            {
               push(@osDetails,$fields[$j]);
               $j++;
            } 
            $globalData{$fields[1]} = $fields[2];
         }
         else
         {
            $globalData{$fields[1]} = $fields[2];
         }
      }
      #------------------------------------------------------------------------------------------------
      # Ignore the BBB data. Not sure what I would do with it if I had it
      #------------------------------------------------------------------------------------------------
      elsif  ($fields[0] =~ /^BBB/)
      {
         $bbbData{$fields[1].'-'.$fields[2]} = join(',',@fields[3..$#fields])
      }
      #------------------------------------------------------------------------------------------------
      # Capture field names and tags 
      #------------------------------------------------------------------------------------------------
      elsif  ($fields[1] !~ /^T\d+/)
      {
         my $itemName =
         $descriptors{$fields[0]} = {'title'    => $fields[1], 
                                     'headings' => []};
         my $i=2;
         while(defined($fields[$i]))
         {
            # These heading will become the names of the items in the DB... make them reasonable
            my $itemName =  $fields[$i];
               $itemName =~ s/\/s/-PerSec/g; # /'s are shortcuts for "per" so spell it out
               $itemName =~ s/\%/Pct/g;      # Spell out Percent... sorta
               $itemName =~ s/\-/_/g;        # consistency in separaters
               
            push(@{$descriptors{$fields[0]}->{'headings'}},$itemName);
            $i++;
         }
      }  
      #------------------------------------------------------------------------------------------------
      # Capture all of the nmon snapshots into a hash. Only record the snapshots that occur after the 
      # lastest time found in the graphite database.
      #------------------------------------------------------------------------------------------------
      elsif  ($fields[1] =~ /^T\d+/)
      {
         if ($fields[0] =~ /^ZZZZ/)
         {
            my $timeStr   = $fields[2];
            my $dateStr   = $fields[3];
            my @dateParts = split(/-/,$dateStr);
            my @timeParts = split(/:/,$timeStr);
            my $dateTime  = $timeParts[2].':'.
                            $timeParts[1].':'.
                            $timeParts[0].' '. 
                            $dateParts[0].'-'.
                            sprintf("%02d",index('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC',$dateParts[1])/3).'-'.
                            $dateParts[2].' ';
            
            $perfData{$fields[1]}->{'time'}      = $timeStr;
            $perfData{$fields[1]}->{'date'}      = $dateStr;
            
            $perfData{$fields[1]}->{'timestamp'} = timelocal(split(/[\s\-:]+/,$dateTime));
         }
         #---------------------------------------------------------------------------------------------
         # only collect the data if it pertains to today and we have not already captured it earlier
         #---------------------------------------------------------------------------------------------
         else
         {  
            if(defined($perfData{$fields[1]}->{'timestamp'}))
            {
               my $i=2;
               while(defined($fields[$i]))
               {
                  $perfData{$fields[1]}->{$fields[0]}->{$descriptors{$fields[0]}->{'headings'}[$i-2]} = $fields[$i];
                  $i++;
               }
            }
         }
      }
      if (defined($perfData{''}))
      {
         print "break\n";
      } 
   }

   #---------------------------------------------------------------------------------------------------
   # If we have a valid input fie, the following variables will have values 
   #---------------------------------------------------------------------------------------------------
   if (!defined($globalData{'host'})) {do_die('unable to glean hostname from input file')}
   if (!defined($globalData{'OS'}))   {do_die('unable to glean hosttype from input file')}
   if (!defined($globalData{'date'})) {do_die('unable to glean start date from input file')}
   if (!defined($globalData{'time'})) {do_die('unable to glean start time from input file')}
}
